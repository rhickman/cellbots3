package ai.cellbots.robot.manager;

import android.content.Context;
import android.media.MediaPlayer;
import android.net.Uri;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.util.Log;

import com.google.firebase.analytics.FirebaseAnalytics;

import java.io.File;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import ai.cellbots.common.ThreadedShutdown;
import ai.cellbots.common.cloud.CloudFileManager;
import ai.cellbots.common.cloud.CloudPath;
import ai.cellbots.common.cloud.CloudSingletonQueueMonitor;
import ai.cellbots.common.data.RobotSound;

public class SoundManager implements ThreadedShutdown {
    private static final String TAG = SoundManager.class.getSimpleName();

    private final CloudSingletonQueueMonitor<RobotSound, SoundManager.Sound> mCloudQueue;
    private final Set<Sound> mSounds = new HashSet<>();
    private final Context mContext;
    private boolean mShutdown = false;
    private final CloudFileManager mLocalManager;
    private final CloudFileManager mGlobalManager;
    private boolean mFullSync;

    // The maximum length of a sound in ms. This limit protects us from bugs in android sounds.
    private static final long SOUND_MAX_TIME = 10 * 1000;
    // The buffer of additional length for a sound to complete before timing out, in ms.
    private static final long SOUND_TIMEOUT_BUFFER = 1000;

    // Event logging
    private static final String EVENT_SOUND_EVENT = "EVENT";
    private static final String EVENT_SOUND_DESCRIPTION = "DESCRIPTION";
    private static final String EVENT_SOUND_LEVEL = "LEVEL";
    private static final String EVENT_SOUND = "SOUND";

    @Override
    public void shutdown() {
        mShutdown = true;
        mLocalManager.shutdown();
        mGlobalManager.shutdown();
        mCloudQueue.shutdown();
        stopAllSounds();
        update();
    }

    @Override
    public void waitShutdown() {
    }

    /**
     * The sound level controls which type of sound is played. This allows the system
     * to evaluate whether a given sound should be played based on robot_preferences.
     */
    public enum SoundLevel {
        AUTOGEN, // Created by an autogenerated goal
        USER, // Created by a user goal
        COMMAND, // Created by commands
        ANIMATION, // Created by animations
        SOUND_BOARD, // Generated by clicking in the cloud sound board
    }

    /**
     * Sound event types for sound logging.
     */
    private enum SoundEvent {
        START, // Sound started playing
        STOP, // Sound.stop() called
        REMOVE, // Sound has been removed
        DISABLED, // Sound category is disabled, stopping the sound
        TIMEOUT, // Sound has timed out
        @SuppressWarnings("unused") ALARM,  // Play the alarm sound effect
        @SuppressWarnings("unused") YOU_RE_WELCOME  // Play the you're welcome sound effect
    }

    /**
     * This class defines a sound that is currently being played by the sound manager. It is
     * returned externally by methods so that other code can monitor sounds to determine when
     * they have finished playing.
     */
    public final class Sound {
        private MediaPlayer mPlayer;
        private final SoundLevel mSoundLevel;
        private final long mStartTime;
        private final boolean mLooping;
        private final long mDuration;
        private final String mDescription;

        /**
         * Creates a sound.
         * @param player The media player to wrap.
         * @param soundLevel The level of sound playing.
         * @param isLooping True if the sound should be looping.
         * @param soundDescription The description of the sound.
         */
        private Sound(@NonNull MediaPlayer player, @NonNull SoundLevel soundLevel,
                boolean isLooping, String soundDescription) {
            mDuration = player.getDuration();
            mPlayer = player;
            mSoundLevel = soundLevel;
            mStartTime = new Date().getTime();
            mLooping = isLooping;
            mDescription = soundDescription;
        }

        /**
         * Returns true if the sound is currently playing. It will return false if the sound
         * finishes (e.g. the whole file has played through) or if the sound is stopped.
         * @return True if playing.
         */
        public synchronized boolean isPlaying() {
            return mPlayer != null && mPlayer.isPlaying();
        }

        /**
         * Returns the string description of this sound.
         * @return The string description.
         */
        public String getDescription() {
            return mDescription;
        }

        /**
         * Computes if the sound has timed out.
         * @return True if the sound has timed out and should stop, false otherwise.
         */
        private boolean soundHasTimedOut() {
            if (mLooping) {
                return false;
            }
            long time = new Date().getTime();
            long duration = Math.max(0, Math.min(mDuration, SOUND_MAX_TIME));
            return time > (mStartTime + duration + SOUND_TIMEOUT_BUFFER);
        }

        /**
         * Gets the SoundLevel of the system.
         * @return The SoundLevel.
         */
        public SoundLevel getSoundLevel() {
            return mSoundLevel;
        }

        /**
         * Stops the sound from playing.
         */
        public synchronized void stop() {
            if (mPlayer != null) {
                soundLog(this, SoundEvent.STOP);
                mPlayer.stop();
                mPlayer.release();
                mPlayer = null;
            }
        }
    }

    /**
     * Create a SoundManager.
     * @param context The android context to play sounds within.
     */
    public SoundManager(Context context) {
        mContext = context;
        mFullSync = false;

        mLocalManager = new CloudFileManager(context, this, "local sounds", "sound",
                "sound_list.bin", CloudPath.LOCAL_SOUNDS_PATH, CloudPath.LOCAL_SOUNDS_STORAGE_PATH);

        mGlobalManager = new CloudFileManager(context, this,
                "global sounds", "global_sound", "sound_list.bin",
                CloudPath.GLOBAL_SOUNDS_PATH, CloudPath.GLOBAL_SOUNDS_STORAGE_PATH);

        mCloudQueue = new CloudSingletonQueueMonitor<>(context, this, CloudPath.ROBOT_SOUND_QUEUE_PATH,
                new CloudSingletonQueueMonitor.Listener<RobotSound, SoundManager.Sound>() {
                    /**
                     * Called when to valid a new sound in the queue.
                     * @param data The element.
                     * @return True if the sound can be played.
                     */
                    @Override
                    public boolean dataElementValid(RobotSound data) {
                        synchronized (SoundManager.this) {
                            // We consider elements valid if the managers have not synchronized yet,
                            // so that they sit in the queue while the managers are downloading.
                            return (!mLocalManager.isSynchronized()
                                    || mLocalManager.fileExists(data.getId())
                                    || !mGlobalManager.isSynchronized()
                                    || mGlobalManager.fileExists(data.getId()));
                        }
                    }
                    /**
                     * Called to stop a sound.
                     * @param stored The element to stop.
                     */
                    @Override
                    public void storedElementFinish(SoundManager.Sound stored) {
                        stored.stop();
                    }
                    /**
                     * Checks if the stored sound is finished.
                     * @param stored The element to check.
                     * @return True if the sound has stopped playing.
                     */
                    @Override
                    public boolean storedElementIsFinished(SoundManager.Sound stored) {
                        return !stored.isPlaying();
                    }
                    /**
                     * Create a Sound element from the cloud RobotSound.
                     * @param data The element.
                     * @return The sound.
                     */
                    @Override
                    public SoundManager.Sound storedElementFromDataElement(RobotSound data) {
                        return playSoundById(data.getId(), SoundManager.SoundLevel.SOUND_BOARD);
                    }

                    /**
                     * Called when the listener is terminated. Does nothing.
                     */
                    @Override
                    public void afterListenerTerminated() {
                        mFullSync = false;
                    }

                    /**
                     * Called when the listener is started. Does nothing.
                     */
                    @Override
                    public void beforeListenerStarted() {

                    }
                }, RobotSound.FACTORY);
    }

    /**
     * Sound types of commands.
     */
    public enum CommandSound {
        START, // Used to play the start command sound
        STOP, // Used to play the stop command sound
    }

    /**
     * Sound types of executive planner goals.
     */
    public enum GoalSound {
        STARTED_GOAL, // Played when a new goal is started.
        COMPLETED_GOAL, // Played when a goal is completed.
        REJECTED_GOAL, // Played when a goal is rejected.
        ALARM, // Play the alarm sound effect.
        YOU_ARE_WELCOME, // Play the you're welcome sound effect.
    }

    /**
     * Log when a sound completes or starts.
     * @param sound The sound to log.
     * @param event The sound event type.
     */
    private void soundLog(Sound sound, SoundEvent event) {
        Log.i(TAG, "Sound event: " + sound.getDescription() + " " + event);
        Bundle bundle = new Bundle();
        bundle.putString(EVENT_SOUND_DESCRIPTION, sound.getDescription());
        bundle.putString(EVENT_SOUND_LEVEL, sound.getSoundLevel().toString());
        bundle.putString(EVENT_SOUND_EVENT, event.toString());
        FirebaseAnalytics.getInstance(mContext).logEvent(EVENT_SOUND, bundle);
    }

    /**
     * Plays a sound from an URI. Acceptable formats are anything the Android SDK will support.
     * The full list is available at
     * https://developer.android.com/guide/topics/media/media-formats.html.
     * @param uri The URI to play.
     * @param soundLevel The sound level.
     * @param looping The sound should loop.
     * @return The sound object.
     */
    public Sound playUriSound(Uri uri, SoundLevel soundLevel, boolean looping) {
        return wrapSoundFromMediaPlayer(MediaPlayer.create(mContext, uri),
                soundLevel, looping, "URI:" + uri);
    }

    /**
     * Wraps a MediaPlayer into a Sound and adds it to the set of currently playing Sound objects.
     * @param player The player, could be null.
     * @param soundLevel The SoundLevel of the sound to play.
     * @param looping If true, the sound will loop continuously.
     * @param description The sound description.
     * @return The Sound object or null.
     */
    private Sound wrapSoundFromMediaPlayer(MediaPlayer player, SoundLevel soundLevel,
            boolean looping, String description) {
        if (player == null) {
            Log.w(TAG, "Warning sound was null");
            return null;
        }
        if (!canPlaySoundLevel(soundLevel)) {
            Log.i(TAG, "Not playing sound for level: " + soundLevel);
            return null;
        }
        player.setLooping(looping);
        player.start();
        Sound r = new Sound(player, soundLevel, looping, description);
        synchronized (this) {
            if (mShutdown) {
                r.stop();
                return null;
            }
            mSounds.add(r);
            soundLog(r, SoundEvent.START);
        }
        return r;
    }

    /**
     * Determine if we can play a given SoundLevel.
     * @param soundLevel The SoundLevel.
     * @return True if we can play it.
     */
    private boolean canPlaySoundLevel(SoundLevel soundLevel) {
        return (soundLevel == SoundLevel.AUTOGEN)
                || (soundLevel == SoundLevel.USER)
                || (soundLevel == SoundLevel.COMMAND)
                || (soundLevel == SoundLevel.ANIMATION)
                || (soundLevel == SoundLevel.SOUND_BOARD);
    }

    /**
     * Sets the metadata of the robot.
     *
     * @param userUuid  The user uuid.
     * @param robotUuid The robot uuid.
     */
    public synchronized void update(final String userUuid, final String robotUuid) {
        mLocalManager.update(userUuid, robotUuid);
        mGlobalManager.update(userUuid, robotUuid);
        mCloudQueue.update(userUuid, robotUuid);
        update();
        if (!mFullSync
                && mLocalManager.isFullySynchronized()
                && mGlobalManager.isFullySynchronized()) {
            mFullSync = true;
        }
    }

    /**
     * Update the sounds queue.
     */
    public synchronized void update() {
        final Set<Sound> finishedSounds = new HashSet<>();
        for (Sound s : mSounds) {
            if (!canPlaySoundLevel(s.getSoundLevel())) {
                soundLog(s, SoundEvent.DISABLED);
                s.stop();
            }
            if (s.isPlaying() && s.soundHasTimedOut()) {
                Log.e(TAG, "Sound timed out: " + s.getDescription());
                s.stop();
                finishedSounds.add(s);
                soundLog(s, SoundEvent.TIMEOUT);
            } else if (!s.isPlaying()) {
                Log.i(TAG, "Sound has finished: " + s.getDescription());
                s.stop();
                finishedSounds.add(s);
                soundLog(s, SoundEvent.REMOVE);
            }
        }
        mSounds.removeAll(finishedSounds);
    }

    /**
     * Stops all existing sounds at a given sound level.
     * @param level Stop sounds at this level.
     */
    @SuppressWarnings("unused")
    public synchronized void stopAllSounds(SoundLevel level) {
        for (Sound s : mSounds) {
            if (s.getSoundLevel() == level) {
                s.stop();
            }
        }
    }

    /**
     * Stops all existing sounds at all levels.
     */
    public synchronized void stopAllSounds() {
        for (Sound s : mSounds) {
            s.stop();
        }
    }

    /**
     * Returns true if we are synchronized with initial set of updates of sounds. The robot should
     * wait for synchronization before taking any actions as it could request a sound before
     * download of the sounds, thus leading to the sound failing to play.
     *
     * @return True if the sounds are synchronized.
     */
    @SuppressWarnings("unused")
    public synchronized boolean isSynchronized() {
        return mFullSync;
    }

    /**
     * Plays a sound.
     *
     * @param sound The sound to play.
     * @param soundLevel The sound level at which the sound will be played.
     */
    public synchronized SoundManager.Sound playSound(String sound, SoundManager.SoundLevel soundLevel) {
        return playSound(sound, soundLevel, false);
    }

    /**
     * Plays a sound.
     *
     * @param sound The sound name to play.
     * @param soundLevel The sound level at which the sound will be played.
     * @param looping If true, the sound will loop until stopped.
     */
    public synchronized SoundManager.Sound playSound(String sound,
                SoundManager.SoundLevel soundLevel, boolean looping) {
        Log.i(TAG, "Try to play sound: " + sound);
        String id = mLocalManager.getIdForName(sound);
        if (id != null) {
            File f = mLocalManager.getFile(id);
            if (f != null) {
                return playUriSound(Uri.fromFile(f), soundLevel, looping);
            } else {
                Log.w(TAG, "Local sound manage couldn't find sound file for " + sound);
            }
        } else {
            Log.w(TAG, "Local sound manager couldn't find sound id for " + sound);
        }
        id = mGlobalManager.getIdForName(sound);
        if (id != null) {
            File f = mGlobalManager.getFile(id);
            if (f != null) {
                return playUriSound(Uri.fromFile(f), soundLevel, looping);
            } else {
                Log.w(TAG, "Global sound manager couldn't find sound file for " + sound);
            }
        } else {
            Log.w(TAG, "Global sound manager couldn't find sound id for " + sound);
        }
        return null;
    }

    /**
     * Plays sound by ID.
     *
     * @param soundId The sound ID to play.
     * @param soundLevel The sound level at which the sound will be played.
     */
    private synchronized SoundManager.Sound playSoundById(String soundId,
                SoundManager.SoundLevel soundLevel) {
        Log.i(TAG, "Try to play soundId: " + soundId);
        File f = mLocalManager.getFile(soundId);
        if (f == null) {
            f = mGlobalManager.getFile(soundId);
            if (f == null) {
                return null;
            }
        }
        return playUriSound(Uri.fromFile(f), soundLevel, false);
    }

    /**
     * Plays a goal sound at the given priority.
     *
     * @param sound The goal sound type to play.
     * @param priority The priority.
     */
    public synchronized SoundManager.Sound playGoalSound(SoundManager.GoalSound sound,
                long priority) {
        Log.i(TAG, "Play goal sound");
        boolean user = (priority >= 100);
        SoundManager.SoundLevel level =
                user ? SoundManager.SoundLevel.USER : SoundManager.SoundLevel.AUTOGEN;
        return playSound("STATIC_" + level + "_" + sound, level,
                sound == SoundManager.GoalSound.ALARM);
    }

    /**
     * Plays a command sound.
     *
     * @param sound The command sound type to play.
     */
    public synchronized SoundManager.Sound playCommandSound(SoundManager.CommandSound sound) {
        return playSound("STATIC_" + SoundManager.SoundLevel.COMMAND + "_" + sound,
                SoundManager.SoundLevel.COMMAND);
    }
}
