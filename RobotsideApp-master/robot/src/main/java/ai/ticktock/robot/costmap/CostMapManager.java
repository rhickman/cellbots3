package ai.cellbots.robot.costmap;

import android.util.Log;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import ai.cellbots.common.EventProcessor;
import ai.cellbots.common.ThreadedShutdown;
import ai.cellbots.common.TimedLoop;
import ai.cellbots.robot.ros.ROSNodeManager;
import ai.cellbots.robot.state.RobotSessionGlobals;

/**
 * Manages multiple CostMaps.
 */
public class CostMapManager implements CostMap.Listener, ThreadedShutdown {
    private static final String TAG = CostMapManager.class.getSimpleName();
    private final ROSNodeManager mROSNodeManager;
    private final Listener mListener;
    private final Map<CostMap.Source, CostMap> mCostMaps;
    private final Map<CostMap.Source, Integer> mCostMapLastUpdate;
    private final double mResolution; // In meters per square.
    private final EventProcessor mEventProcessor;
    @SuppressWarnings("unused")
    private final RobotSessionGlobals mSession;
    private final Map<CostMap.Source, Map<CostMapInflator.Type, CostMap>> mCostMapByType = new HashMap<>();
    private final CostMapInflator mCostMapInflator;
    private final CostMapFuser mCostMapFuser;
    // CostMap generated by fusing the static sources
    // that were inflated using the full robot radius.
    private CostMap mFullyInflatedStaticCostMap = null;
    // CostMap generated by fusing the static sources
    // that were inflated using the robot radius multiplied by a factor.
    private CostMap mProportionallyInflatedStaticCostMap = null;
    // CostMap generated by fusing the static and dynamic sources
    // that were inflated using the full robot radius.
    private CostMap mFullyInflatedOutputCostMap = null;
    // CostMap generated by fusing the static and dynamic sources
    // that were inflated using the robot radius multiplied by a factor.
    private CostMap mProportionallyInflatedOutputCostMap = null;
    private final HashSet<CostMap.Source> mUpdatedCostMaps = new HashSet<>();

    // The static sources for generating an output costmap
    private static final List<CostMap.Source> STATIC_SOURCES = Collections.unmodifiableList(
            Arrays.asList(CostMap.Source.FLOORPLAN, CostMap.Source.PRIOR_TRAJECTORY));

    // The dynamic sources for generating an output costmap
    private static final List<CostMap.Source> DYNAMIC_SOURCES = Collections.unmodifiableList(
            Arrays.asList(CostMap.Source.COMPUTER_VISION));

    // All the sources (static and dynamic) for generating an output costmap
    private static final List<CostMap.Source> ALL_SOURCES = Collections.unmodifiableList(
            Arrays.asList(CostMap.Source.FLOORPLAN, CostMap.Source.PRIOR_TRAJECTORY, CostMap.Source.COMPUTER_VISION));

    /**
     * Listener for the CostMap.
     */
    public interface Listener {
        /**
         * Called when a new CostMap is generated. Little logic should be done in the result
         * because it occurs on the CostMapManager thread.
         *
         * @param manager The CostMapManager that was updated.
         */
        void onNewCostMap(CostMapManager manager);
    }

    /**
     * Gets the fully inflated static CostMap, containing the fused static sources.
     * Always cache the pointer locally before doing logic on the CostMap.
     *
     * @return The fully inflated static CostMap or null.
     */
    public CostMap getFullyInflatedStaticCostMap() {
        return mFullyInflatedStaticCostMap;
    }

    /**
     * Gets the proportionally inflated static CostMap, containing the fused static sources.
     * Always cache the pointer locally before doing logic on the CostMap.
     *
     * @return The proportionally inflated static CostMap or null.
     */
    public CostMap getProportionallyInflatedStaticCostMap() {
        return mProportionallyInflatedStaticCostMap;
    }

    /**
     * Gets the fully inflated output CostMap, containing the fused static and dynamic sources.
     * Always cache the pointer locally before doing logic on the CostMap.
     *
     * @return The fully inflated output CostMap or null.
     */
    public CostMap getFullyInflatedOutputCostMap() {
        return mFullyInflatedOutputCostMap;
    }

    /**
     * Gets the proportionally inflated output CostMap, containing the fused static and dynamic sources.
     * Always cache the pointer locally before doing logic on the CostMap.
     *
     * @return The proportionally inflated output CostMap or null.
     */
    public CostMap getProportionallyInflatedOutputCostMap() {
        return mProportionallyInflatedOutputCostMap;
    }

    /**
     * Creates the CostMap manager.
     *
     * @param rosNodeManager The ROS node manager.
     * @param session        The session.
     * @param costMaps       The collection of CostMaps to store.
     * @param listener       The listeners for the CostMap updates.
     * @param inflator       The CostMapInflator.
     * @param fuser          The CostMapFuser.
     * @param resolution     The resolution in meters per square.
     */
    public CostMapManager(ROSNodeManager rosNodeManager, RobotSessionGlobals session, Collection<CostMap> costMaps,
                          Listener listener, CostMapInflator inflator, CostMapFuser fuser, double resolution) {
        mROSNodeManager = rosNodeManager;
        mListener = listener;
        mSession = session;
        mCostMapFuser = fuser;
        mCostMapInflator = inflator;
        Map<CostMap.Source, CostMap> costMapsBySource = new HashMap<>();

        for (CostMap costMap : costMaps) {
            if (costMapsBySource.containsKey(costMap.getSource())) {
                throw new IllegalArgumentException(
                        "Duplicate CostMap for source: " + costMap.getSource());
            }
            if (costMap.getResolution() != resolution) {
                throw new IllegalArgumentException("CostMap has invalid resolution for source: "
                        + costMap.getSource() + " got " + costMap.getResolution() + " wanted"
                        + resolution);
            }
            costMapsBySource.put(costMap.getSource(), costMap);
        }
        mResolution = resolution;
        mCostMaps = Collections.unmodifiableMap(costMapsBySource);
        mCostMapLastUpdate = new HashMap<>();

        // Set listener to all cost maps.
        for (CostMap map : mCostMaps.values()) {
            map.setListener(this);
            mUpdatedCostMaps.add(map.getSource());
        }

        mEventProcessor = new EventProcessor(TAG, new EventProcessor.Processor() {
            @Override
            public boolean update() {
                if (createUpdatedCostMap()) {
                    mListener.onNewCostMap(CostMapManager.this);
                }
                return true;
            }

            @Override
            public void shutdown() {
            }
        });
        mEventProcessor.onEvent();
    }

    /**
     * Called when a CostMap is updated.
     *
     * @param costMap     The CostMap that was update.
     * @param updateCount The count of current update, used for dropping stale updates.
     */
    @Override
    public void onCostMapUpdate(CostMap costMap, int updateCount) {
        if (ALL_SOURCES.contains(costMap.getSource())) {
            mEventProcessor.onEvent();
        }
    }

    /**
     * Updates the CostMaps.
     *
     * @return True if an update was pushed.
     */
    private synchronized boolean createUpdatedCostMap() {
        boolean valid = true;
        // Extract the regions of interest for each CostMap
        for (CostMap.Source costMapSource : ALL_SOURCES) {
            if (!mCostMaps.containsKey(costMapSource)) {
                Log.i(TAG, "CostMap " + costMapSource + " is not loaded");
                continue;
            }
            CostMap costMap = mCostMaps.get(costMapSource);
            //noinspection SynchronizationOnLocalVariableOrMethodParameter
            synchronized (costMap) {
                if (!costMap.isValid()) {
                    Log.w(TAG, "Invalid CostMap: " + costMapSource);
                    // Valid is set to false only if one of the static costmaps is invalid
                    // Because we still want to generate an output costmap if a dynamic costmap is invalid
                    if (STATIC_SOURCES.contains(costMapSource)) {
                        valid = false;
                    }
                    mUpdatedCostMaps.add(costMap.getSource());
                    if (mCostMapByType.containsKey(costMap.getSource())) {
                        mCostMapByType.remove(costMap.getSource());
                    }
                    if (mCostMapLastUpdate.containsKey(costMap.getSource())) {
                        mCostMapLastUpdate.remove(costMap.getSource());
                    }
                } else if (!mCostMapLastUpdate.containsKey(costMap.getSource())
                        || mCostMapLastUpdate.get(costMap.getSource())
                        != costMap.getUpdateCount()) {
                    mCostMapLastUpdate.put(costMap.getSource(), costMap.getUpdateCount());
                    byte[] fullRadiusInflatedCostMapByteArray = costMap.requiresInflation()
                            ? mCostMapInflator.inflateCostMapFullRadius(costMap)
                            : costMap.getFullCostRegion();
                    byte[] factorRadiusInflatedCostMapByteArray = costMap.requiresInflation()
                            ? mCostMapInflator.inflateCostMapFactorRadius(costMap)
                            : costMap.getFullCostRegion();
                    CostMap fullRadiusInflatedCostMap = new FixedGridCostMap(costMap.getSource(), mResolution,
                            costMap.getBoundingWidth(), costMap.getBoundingHeight(),
                            costMap.getLowerXLimit(), costMap.getLowerYLimit(),
                            fullRadiusInflatedCostMapByteArray, true);
                    CostMap factorRadiusInflatedCostMap = new FixedGridCostMap(costMap.getSource(), mResolution,
                            costMap.getBoundingWidth(), costMap.getBoundingHeight(),
                            costMap.getLowerXLimit(), costMap.getLowerYLimit(),
                            factorRadiusInflatedCostMapByteArray, true);
                    Map<CostMapInflator.Type, CostMap> costMaps = new HashMap<>();
                    costMaps.put(CostMapInflator.Type.FULL_RADIUS, fullRadiusInflatedCostMap);
                    costMaps.put(CostMapInflator.Type.FACTOR_RADIUS, factorRadiusInflatedCostMap);
                    mCostMapByType.put(costMap.getSource(), costMaps);
                    Log.i(TAG, "Merged in CostMap " + costMap.getSource() + ": X: ["
                            + costMap.getLowerXLimit() + ", " + costMap.getUpperXLimit()
                            + "] Y: [" + costMap.getLowerYLimit()
                            + ", " + costMap.getUpperYLimit() + "]");
                    mUpdatedCostMaps.add(costMap.getSource());
                }
            }
        }

        // If at least one static costmap is invalid, then clear the CostMap out.
        if (!valid) {
            boolean hadMap = (mFullyInflatedOutputCostMap != null) &&
                    (mProportionallyInflatedOutputCostMap != null);
            mFullyInflatedOutputCostMap = null;
            mProportionallyInflatedOutputCostMap = null;
            return hadMap;
        }

        // See if we need a static update and store all static maps
        List<CostMap> fullyInflatedStaticMaps = new LinkedList<>();
        List<CostMap> proportionallyInflatedStaticMaps = new LinkedList<>();
        boolean staticUpdate = false;
        for (CostMap.Source source : STATIC_SOURCES) {
            if (ALL_SOURCES.contains(source) && mCostMapByType.containsKey(source)) {
                fullyInflatedStaticMaps.add(mCostMapByType.get(source).get(
                        CostMapInflator.Type.FULL_RADIUS));
                proportionallyInflatedStaticMaps.add(mCostMapByType.get(source).get(
                        CostMapInflator.Type.FACTOR_RADIUS));
                staticUpdate = staticUpdate || mUpdatedCostMaps.contains(source);
            }
        }
        if (staticUpdate || mFullyInflatedStaticCostMap == null ||
                mProportionallyInflatedStaticCostMap == null) {
            Log.i(TAG, "Fusing " + mCostMapByType.size() + " static CostMaps");
            mFullyInflatedStaticCostMap = mCostMapFuser.fuseCostMaps(
                    fullyInflatedStaticMaps,
                    CostMap.Source.STATIC_COSTMAP_FULLY_INFLATED);
            mProportionallyInflatedStaticCostMap = mCostMapFuser.fuseCostMaps(
                    proportionallyInflatedStaticMaps,
                    CostMap.Source.STATIC_COSTMAP_PROPORTIONALLY_INFLATED);
        }

        List<CostMap> fullyInflatedDynamicMaps = new LinkedList<>();
        List<CostMap> proportionallyInflatedDynamicMaps = new LinkedList<>();
        // If static costmap is updated, then output costmap should be updated as well
        // Even if none of the dynamic costmaps are updated
        boolean dynamicUpdate = staticUpdate;

        // mUpdatedCostMaps will contain the information if a costmap needs updating
        // mCostMapData will contain the data of the updated costmap
        // If mUpdatedCostMaps contains a source but mCostMapData doesn't, it means a costmap is cleared
        for (CostMap.Source source : DYNAMIC_SOURCES) {
            if (mUpdatedCostMaps.contains(source)) {
                dynamicUpdate = true;
                if (mCostMapByType.containsKey(source)) {
                    fullyInflatedDynamicMaps.add(mCostMapByType.get(source).get(
                            CostMapInflator.Type.FULL_RADIUS));
                    proportionallyInflatedDynamicMaps.add(mCostMapByType.get(source).get(
                            CostMapInflator.Type.FACTOR_RADIUS));
                }
            }
        }

        if(dynamicUpdate && fullyInflatedStaticMaps != null &&
                proportionallyInflatedStaticMaps != null) {
            // If all the dynamic costmaps are cleared, then set the output costmap using the fused static costmap
            if (fullyInflatedDynamicMaps.size() == 0 ||
                    proportionallyInflatedDynamicMaps.size() == 0) {
                mFullyInflatedOutputCostMap = new FixedGridCostMap(
                        CostMap.Source.OUTPUT_COSTMAP_FULLY_INFLATED,
                        mFullyInflatedStaticCostMap.getResolution(),
                        mFullyInflatedStaticCostMap.getBoundingWidth(),
                        mFullyInflatedStaticCostMap.getBoundingHeight(),
                        mFullyInflatedStaticCostMap.getLowerXLimit(),
                        mFullyInflatedStaticCostMap.getLowerYLimit(),
                        mFullyInflatedStaticCostMap.getFullCostRegion(), true);
                mProportionallyInflatedOutputCostMap = new FixedGridCostMap(
                        CostMap.Source.OUTPUT_COSTMAP_PROPORTIONALLY_INFLATED,
                        mProportionallyInflatedStaticCostMap.getResolution(),
                        mProportionallyInflatedStaticCostMap.getBoundingWidth(),
                        mProportionallyInflatedStaticCostMap.getBoundingHeight(),
                        mProportionallyInflatedStaticCostMap.getLowerXLimit(),
                        mProportionallyInflatedStaticCostMap.getLowerYLimit(),
                        mProportionallyInflatedStaticCostMap.getFullCostRegion(), true);
            } else {
                // TODO this is not an efficient way to fuse the dynamic costmaps with the fused static costmap
                // TODO write a new fuseCostMaps function for fusing multiple dynamic costmaps with one fused static costmap
                fullyInflatedDynamicMaps.add(mFullyInflatedStaticCostMap);
                proportionallyInflatedDynamicMaps.add(mProportionallyInflatedStaticCostMap);
                mFullyInflatedOutputCostMap = mCostMapFuser.fuseCostMaps(
                        fullyInflatedDynamicMaps,
                        CostMap.Source.OUTPUT_COSTMAP_FULLY_INFLATED);
                mProportionallyInflatedOutputCostMap = mCostMapFuser.fuseCostMaps(
                        proportionallyInflatedDynamicMaps,
                        CostMap.Source.OUTPUT_COSTMAP_PROPORTIONALLY_INFLATED);
            }
        }

        // Send the CostMaps to the ROS node for visualization.
        for (CostMap.Source updated : mUpdatedCostMaps) {
            if (mCostMapByType.containsKey(updated)) {
                mROSNodeManager.publishGrid(mCostMapByType.get(updated).get(CostMapInflator.Type.FULL_RADIUS));
            }
        }
        if (staticUpdate && mFullyInflatedStaticCostMap != null &&
                mProportionallyInflatedStaticCostMap != null) {
            mROSNodeManager.publishGrid(mFullyInflatedStaticCostMap);
            mROSNodeManager.publishGrid(mProportionallyInflatedStaticCostMap);
        }
        if (dynamicUpdate && mFullyInflatedOutputCostMap != null &&
                mProportionallyInflatedOutputCostMap != null) {
            mROSNodeManager.publishGrid(mFullyInflatedOutputCostMap);
            mROSNodeManager.publishGrid(mProportionallyInflatedOutputCostMap);
        }

        mUpdatedCostMaps.clear();

        Log.i(TAG, "Completed CostMap publication of " + mFullyInflatedOutputCostMap);

        return dynamicUpdate;
    }

    @Override
    public void shutdown() {
        mEventProcessor.shutdown();
        for (CostMap costMap : mCostMaps.values()) {
            costMap.shutdown();
        }
    }

    @Override
    public void waitShutdown() {
        shutdown();
        List<ThreadedShutdown> shutdownList = new ArrayList<>(mCostMaps.size() + 2);
        shutdownList.add(mEventProcessor);
        shutdownList.addAll(mCostMaps.values());
        TimedLoop.efficientShutdown(shutdownList);
    }
}
