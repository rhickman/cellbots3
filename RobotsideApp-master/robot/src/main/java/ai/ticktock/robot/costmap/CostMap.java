package ai.cellbots.robot.costmap;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import ai.cellbots.common.ThreadedShutdown;
import ai.cellbots.common.Transform;
import ai.cellbots.common.concurrent.AtomicEnum;

/**
 * A map from 2D coordinates to cost. The costs are of type 'byte', although the allowed range for
 * them is 0 to 127. The lowest limit (0) represents free space and the highest (127) occupied
 * space. Negative values are not considered.
 *
 * The 2D coordinates (x, y) are continuous. They are discretized to a costmap cell through flooring.
 * For example, assume 1D coordinates of: 0.1, 1.1, 2.1, 2.6. 3.0
 * 0.1 maps to cell 0
 * 1.1 maps to cell 1
 * 2.1 maps to cell 2
 * 2.6 maps to cell 2
 * 3.0 maps to cell 3
 *
 * This class is thread safe.
 */
public abstract class CostMap implements ThreadedShutdown {
    /**
     * Represents the data source of the CostMap.
     */
    public enum Source {
        FLOORPLAN,
        OCTOMAP,
        BUMPER,
        PRIOR_TRAJECTORY,
        COMPUTER_VISION,
        // CostMap generated by fusing the static sources
        // that were inflated using the full robot radius.
        STATIC_COSTMAP_FULLY_INFLATED,
        // CostMap generated by fusing the static sources
        // that were inflated using the robot radius multiplied by a factor.
        STATIC_COSTMAP_PROPORTIONALLY_INFLATED,
        // CostMap generated by fusing the static and dynamic sources
        // that were inflated using the full robot radius.
        OUTPUT_COSTMAP_FULLY_INFLATED,
        // CostMap generated by fusing the static and dynamic sources
        // that were inflated using the robot radius multiplied by a factor.
        OUTPUT_COSTMAP_PROPORTIONALLY_INFLATED
    }

    /**
     * A listener for updates to the CostMap.
     */
    interface Listener {
        /**
         * Called when the CostMap is updated.
         *
         * @param costMap     The CostMap that was updated.
         * @param updateCount The count of current update, used for dropping stale updates.
         */
        void onCostMapUpdate(CostMap costMap, int updateCount);
    }

    // The data source.
    private final AtomicEnum<Source> mSource = new AtomicEnum<>(Source.FLOORPLAN);

    // TODO(playerone) Resolution is linked to a grid. The generic costmap should be independent
    // of this as we could, in a future, have costmaps which are not linked to a grid. We
    // should rather make this a variable within the grid costmap class.
    private final double mResolution; // The resolution, the width of a square in meters.
    private Listener mListener; // The listener for the CostMap.
    private AtomicInteger mUpdateCounter; // Stores what update edition of the CostMap is current.
    private AtomicBoolean mIsValid; // True if the CostMap is invalid.
    public static final byte MIN_COST = 0;
    public static final byte MAX_COST = 127;
    public static final byte MAX_FREE_COST = 126;
    public static final byte OBSTACLE_COST = 127;

    /**
     * Creates the CostMap.
     *
     * @param source     The source of the CostMap data.
     * @param resolution The resolution of the CostMap, being the width of a square in meters.
     */
    protected CostMap(Source source, double resolution) {
        // Sanity checks
        if (resolution <= 0) {
            throw new Error("Resolution should be greater than 0");
        }
        mSource.set(source);
        mResolution = resolution;
        mUpdateCounter = new AtomicInteger(0);
        mListener = null;
        mIsValid = new AtomicBoolean(false);
    }

    /**
     * If true, then the CostMap is mutable.
     *
     * @return True if the CostMap can be altered after creation.
     */
    public boolean isMutable() {
        return true;
    }

    /**
     * Get if the CostMap requires inflation.
     *
     * @return True if the CostMap requires inflation.
     */
     public boolean requiresInflation() {
         return true;
     }

    /**
     * Sets if the CostMap is valid.
     *
     * @param valid True if valid.
     */
    final protected void setValid(boolean valid) {
        mIsValid.set(valid);
    }

    /**
     * Gets the map's validity.
     *
     * @return True if valid.
     */
    final public boolean isValid() {
        return mIsValid.get();
    }

    /**
     * Sets the listener for the CostMap.
     *
     * @param listener The listener for the CostMap.
     */
    final void setListener(Listener listener) {
        mListener = listener;
    }

    /**
     * Gets the update count of the CostMap.
     *
     * @return The update count.
     */
    final int getUpdateCount() {
        return mUpdateCounter.get();
    }

    /**
     * Should be called by subclass after a CostMap update.
     */
    final protected void onCostMapUpdate() {
        Listener listener = mListener;
        int update = mUpdateCounter.getAndIncrement();
        if (listener != null) {
            listener.onCostMapUpdate(this, update);
        }
    }

    /**
     * Gets the source of the CostMap.
     *
     * @return CostMap source.
     */
    final public Source getSource() {
        return mSource.get();
    }

    /**
     * Gets the resolution of the CostMap, in meters per square.
     *
     * @return CostMap resolution, meters per square.
     */
    final public double getResolution() {
        return mResolution;
    }

    /**
     * Gets the CostMap data at a given point, specified by a CostMapPose.
     *
     * @param position The CostMapPose to get the cost for.
     * @return Cost in byte. It goes from 0 to 127, never returning negative values.
     */
    public final byte getCost(CostMapPose position) {
        return getCost(position.getX(), position.getY());
    }

    /**
     * Gets the CostMap data at a given point in the world coordinates, specified by doubles.
     *
     * @param x The x position in the world coordinates.
     * @param y The y position in the world coordinates.
     *
     * @return Cost in byte.
     */
    public final byte getCostAtPosition(double x, double y) {
        return getCost(discretize(x, y));
    }

    /**
     * Gets the CostMap data at a given point in the CostMap coordinates, specified by integer.
     *
     * @param x_index  The x coordinate in the CostMap coordinates. Between x limits.
     * @param y_index  The y coordinate in the CostMap coordinates. Between y limits.
     * @return Cost in byte.
     */
    public abstract byte getCost(int x_index, int y_index);

    /**
     * Gets the CostMap data over a region.
     *
     * @param xStart The start x coordinate in the CostMap coordinates. Include this.
     * @param yStart The start y coordinate in the CostMap coordinates. Include this.
     * @param xEnd   The end x coordinate in the CostMap coordinates. Exclude this.
     * @param yEnd   The end y coordinate in the CostMap coordinates. Exclude this.
     * @return The array of byte cost values in the form of {x11 x12 ... x1n, x21 x22 ... x2n}.
     */
    @SuppressWarnings("WeakerAccess")
    public byte[] getCostRegion(int xStart, int yStart, int xEnd, int yEnd) {
        if (xStart > xEnd) {
            throw new IllegalArgumentException("The start is after the end for X axis: ["
                    + xStart + ", " + xEnd + "]");
        }
        if (yStart > yEnd) {
            throw new IllegalArgumentException("The start is after the end for Y axis: ["
                    + yStart + ", " + yEnd + "]");
        }
        int width = xEnd - xStart;
        int height = yEnd - yStart;
        if (width == 0) {
            return new byte[0];
        } else if (height == 0) {
            return new byte[0];
        }
        byte[] region = new byte[width * height];
        for (int x = xStart; x < xEnd; x++) {
            for (int y = yStart; y < yEnd; y++) {
                region[(y - yStart) * width + x - xStart] = getCost(x, y);
            }
        }
        return region;
    }

    /**
     * Gets the highest CostMap cost in a region.
     *
     * @param xStart The start x coordinate in the CostMap coordinates.
     * @param yStart The start y coordinate in the CostMap coordinates.
     * @param xEnd   The end x coordinate in the CostMap coordinates.
     * @param yEnd   The end y coordinate in the CostMap coordinates.
     * @return The highest CostMap cost in a region.
     */
    @SuppressWarnings("WeakerAccess")
    public byte getHighestCostInRegion(int xStart, int yStart, int xEnd, int yEnd) {
        if (xStart > xEnd) {
            throw new IllegalArgumentException("The start is after the end for X axis: ["
                    + xStart + ", " + xEnd + "]");
        }
        if (yStart > yEnd) {
            throw new IllegalArgumentException("The start is after the end for Y axis: ["
                    + yStart + ", " + yEnd + "]");
        }
        if (xStart == xEnd) {
            return MIN_COST;
        } else if (yStart == yEnd) {
            return MIN_COST;
        }
        byte cost = MIN_COST;
        for (int x = xStart; x < xEnd; x++) {
            for (int y = yStart; y < yEnd; y++) {
                cost = (byte) Math.max(cost, getCost(x, y));
                if (cost == MAX_COST) {
                    return cost;
                }
            }
        }
        return cost;
    }

    /**
     * Determines if a cost byte is an obstacle.
     *
     * @param cost The cost byte of a cost grid.
     * @return True if the byte is an obstacle.
     */
    public static boolean isObstacle(byte cost) {
        return cost == OBSTACLE_COST;
    }

    /**
     * Gets the CostMap data over a region specified by its limit points.
     *
     * @param xStart The start x coordinate.
     * @param yStart The start y coordinate.
     * @param xEnd   The end x coordinate.
     * @param yEnd   The end y coordinate.
     * @return The array of byte cost values in the form of {x11 x12 ... x1n, x21 x22 ... x2n}.
     */
    @SuppressWarnings("unused")
    public byte[] getCostRegionViaPoints(double xStart, double yStart, double xEnd,
                                                        double yEnd) {
        // TODO: (playerone) For implementing this method we need to discretize the arguments,
        // TODO: so that the elements returned match the locations in the map asked for. This is
        // TODO: left here for now, but it should be moved to the grid class.
        CostMapPose startPoint = discretize(xStart, yStart);
        CostMapPose endPoint = discretize(xEnd, yEnd);

        return getCostRegion(startPoint.getX(), startPoint.getY(), endPoint.getX(),
                endPoint.getY());
    }

    /**
     * Gets the entire CostMap data, by getting the region from the lower limit to the upper limit.
     *
     * @return The entire CostMap, starting at the lower limits.
     */
    public byte[] getFullCostRegion() {
        return getCostRegion(getLowerXLimit(), getLowerYLimit(),
                getUpperXLimit(), getUpperYLimit());
    }

    /**
     * Gets the lower limit of the region of interest as a grid cell coordinate.
     *
     * @return The x coordinate of the lower limit of the region of interest, in grid cells.
     */
    public abstract int getLowerXLimit();

    /**
     * Gets the lower limit of the region of interest as a grid cell coordinate.
     *
     * @return The y coordinate of the lower limit of the region of interest, in grid cells.
     */
    public abstract int getLowerYLimit();

    /**
     * Gets the upper limit of the region of interest as a grid cell coordinate.
     *
     * @return The x coordinate of the upper limit of the region of interest, in grid cells.
     */
    public abstract int getUpperXLimit();

    /**
     * Gets the upper limit of the region of interest as a grid cell coordinate.
     *
     * @return The y coordinate of the upper limit of the region of interest, in grid cells.
     */
    public abstract int getUpperYLimit();

    /**
     * Gets the width of the bounding box containing the CostMap, in grid cells.
     *
     * @return The width of the bounding box containing the CostMap, in grid cells.
     */
    public abstract int getBoundingWidth();

    /**
     * Gets the height of the bounding box containing the CostMap, in grid cells.
     *
     * @return The height of the bounding box containing the CostMap, in grid cells.
     */
    public abstract int getBoundingHeight();

    /**
     * Looks for the neighbors of a CostMapPose in the cost map, whose costs are less than or equal
     * to an indicated value. Ideally finds the 8 neighbors of a cell and, in case of the outermost
     * ones, the neighbors are only the adjacent cells which fall inside the costmap (3 for a
     * corner, 5 for a lateral).
     *
     * @param pose    A CostMapPose to look neighbors for.
     * @param maxCost The maximum cost allowed for the returned neighbors.
     * @return a list of neighbors for the specified pose.
     */
    public abstract List<CostMapPose> neighborsFor(CostMapPose pose, byte maxCost);

    /**
     * Gets all the discretized coordinates in the map.
     *
     * @return a list of all the cost map poses in the map, with an arbitrary ordering.
     */
    public abstract List<CostMapPose> getAllCostMapPoses();

    /**
     * Discretizes a continuous-valued ordered pair. Throws an exception if the coordinate falls out
     * of the cost map's bounds. The discretization is done through flooring as explained in the
     * class documentation above.
     *
     * @param x A double x coordinate to convert.
     * @param y A double y coordinate to convert.
     * @return the discretized coordinate as a CostMapPose.
     */
    public final CostMapPose discretize(double x, double y) {
        return new CostMapPose((int) Math.floor(x / mResolution), (int) Math.floor(y / mResolution));
    }

    /**
     * Converts a pose to the real world coordinates.
     *
     * @param pose The pose to convert.
     * @return The transform.
     */
    public final Transform toWorldCoordinates(CostMapPose pose) {
        return pose.toWorldCoordinates(mResolution);
    }

    /**
     * Returns a string of the CostMap description.
     *
     * @return CostMap description string.
     */
    public abstract String toString();
}
