package ai.cellbots.pathfollower;

import ai.cellbots.common.Geometry;
import ai.cellbots.common.Transform;

/**
 * The concept of the pure pursuit approach is to calculate the curvature that will take the
 * vehicle from its current position to a goal position. A circle is then defined in such a way
 * that it passes through both the goal point and the current vehicle position. Finally a control
 * algorithm chooses a steering angle in relation to this circle.
 */
public class PurePursuit {
    // The robot sees behind a lookahead distance
    private double lookaheadDistance;
    // Tweak parameter for curvature output
    private double angularModification = 1.0;

    /**
     * Constructor
     *
     * @param lookaheadDistance Parameter distance of the algorithm
     */
    public PurePursuit(double lookaheadDistance) {
        // Initialization
        this.lookaheadDistance = lookaheadDistance;
    }

    /**
     * Computes the target point at certain lookahead distance from the nearest point in the line
     *
     * @param initialPointOfLine First point of the line
     * @param finalPointOfLine   Seconds point of the line
     * @param nearestPoint       Point at which the target point should be taken
     * @return Coordinates of the target point
     */
    private double[] getGoalPointAtLookaheadDistance(
            double[] initialPointOfLine, double[] finalPointOfLine, double[] nearestPoint) {

        // TODO: use lookahead distance proportional to robot max speed -> 0.5 * getRobotMaxSpeed()
        return Geometry.getPointAtDistance(
                initialPointOfLine, finalPointOfLine, nearestPoint, lookaheadDistance);
    }

    /**
     * Computes the necessary curvature to move the robot from its position to the next node
     *
     * @param initialTransform Robot transform
     * @param targetNode       Target node
     * @param nextNode         Next node
     * @return Curvature parameter
     */
    public double computeCurvatureToReach(
            Transform initialTransform, double[] targetNode, double[] nextNode) {

        // Takes the closest point from robot in the line generated by the goal node and the next
        double[] nearestPoint = Geometry.getIntersectionBetweenLineAndPerpendicularPoint(
                targetNode, nextNode, initialTransform.getPosition());
        // Generates a goal point from the nearest point distanced at a lookahead distance
        double[] goalPoint = getGoalPointAtLookaheadDistance(targetNode, nextNode, nearestPoint);
        // Computes the rotation necessary to reach the goal
        // TODO: If curvature * {angularModification} > ANGULAR_VELOCITY_LIMIT -> Saturate
        return Geometry.computeCurvature(
                initialTransform.getPosition(), initialTransform.getRotationZ(), goalPoint)
                * angularModification;
    }

    /**
     * Checks if the robot is near the {goalNode}
     *
     * @param initialTransform Robot transform
     * @param goalNode         Goal coordinates (x,y)
     * @return If the robot is at certain lookahead distance of the {goalNode}
     */
    public boolean shouldMove(Transform initialTransform, double[] goalNode) {
        double distToGoal =
                Geometry.getDistanceBetweenTwoPoints(initialTransform.getPosition(), goalNode);
        // Call next node
        return distToGoal <= lookaheadDistance;
    }

}
