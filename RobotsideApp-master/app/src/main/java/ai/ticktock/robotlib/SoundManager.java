package ai.cellbots.robotlib;

import android.content.Context;
import android.content.SharedPreferences;
import android.media.MediaPlayer;
import android.net.Uri;
import android.os.Bundle;
import android.preference.PreferenceManager;
import android.support.annotation.NonNull;
import android.util.Log;

import com.google.firebase.analytics.FirebaseAnalytics;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import ai.cellbots.robotapp.R;

/**
 * Manages sounds for the robot. The sounds are loaded from files and played on command. The
 * system tracks the playing sounds, so that external code can wait for the sounds to stop.
 * The SoundManager defines different levels of sound, which correspond to robot_preferences settings
 * that can be changed by users to enable or disable types of sounds.
 */
public class SoundManager {
    private static final String TAG = SoundManager.class.getSimpleName();
    private final Context mContext;
    private final Set<Sound> mSounds = new HashSet<>();
    private final SharedPreferences mSharedPreferences;
    private boolean mUserSoundsEnabled = true;
    private boolean mAutogenSoundsEnabled = true;
    private boolean mCommandSoundsEnabled = true;

    private boolean mShutdown = false;

    // The maximum length of a sound in ms. This limit protects us from bugs in android sounds.
    private static final long SOUND_MAX_TIME = 10 * 1000;
    // The buffer of additional length for a sound to complete before timing out, in ms.
    private static final long SOUND_TIMEOUT_BUFFER = 1000;

    // Event logging
    private static final String EVENT_SOUND_EVENT = "EVENT";
    private static final String EVENT_SOUND_DESCRIPTION = "DESCRIPTION";
    private static final String EVENT_SOUND_LEVEL = "LEVEL";
    private static final String EVENT_SOUND = "SOUND";

    /**
     * The sound level controls which type of sound is played. This allows the system
     * to evaluate whether a given sound should be played based on robot_preferences.
     */
    public enum SoundLevel {
        AUTOGEN, // Created by an autogenerated goal
        USER, // Created by a user goal
        COMMAND, // Created by commands
        ANIMATION, // Created by animations
        SOUND_BOARD, // Generated by clicking in the cloud sound board
    }

    /**
     * Sound event types for sound logging.
     */
    private enum SoundEvent {
        START, // Sound started playing
        STOP, // Sound.stop() called
        REMOVE, // Sound has been removed
        DISABLED, // Sound category is disabled, stopping the sound
        TIMEOUT // Sound has timed out
    }

    /**
     * This class defines a sound that is currently being played by the sound manager. It is
     * returned externally by methods so that other code can monitor sounds to determine when
     * they have finished playing.
     */
    public final class Sound {
        private MediaPlayer mPlayer;
        private final SoundLevel mSoundLevel;
        private final long mStartTime;
        private final boolean mLooping;
        private final long mDuration;
        private final String mDescription;

        /**
         * Creates a sound.
         * @param player The media player to wrap.
         * @param soundLevel The level of sound playing.
         * @param isLooping True if the sound should be looping.
         * @param soundDescription The description of the sound.
         */
        private Sound(@NonNull MediaPlayer player, @NonNull SoundLevel soundLevel,
                boolean isLooping, String soundDescription) {
            mDuration = player.getDuration();
            mPlayer = player;
            mSoundLevel = soundLevel;
            mStartTime = new Date().getTime();
            mLooping = isLooping;
            mDescription = soundDescription;
        }

        /**
         * Returns true if the sound is currently playing. It will return false if the sound
         * finishes (e.g. the whole file has played through) or if the sound is stopped.
         * @return True if playing.
         */
        public synchronized boolean isPlaying() {
            return mPlayer != null && mPlayer.isPlaying();
        }

        /**
         * Returns the string description of this sound.
         * @return The string description.
         */
        public String getDescription() {
            return mDescription;
        }

        /**
         * Computes if the sound has timed out.
         * @return True if the sound has timed out and should stop, false otherwise.
         */
        private boolean soundHasTimedOut() {
            if (mLooping) {
                return false;
            }
            long time = new Date().getTime();
            long duration = Math.max(0, Math.min(mDuration, SOUND_MAX_TIME));
            return time > (mStartTime + duration + SOUND_TIMEOUT_BUFFER);
        }

        /**
         * Gets the SoundLevel of the system.
         * @return The SoundLevel.
         */
        public SoundLevel getSoundLevel() {
            return mSoundLevel;
        }

        /**
         * Stops the sound from playing.
         */
        public synchronized void stop() {
            if (mPlayer != null) {
                soundLog(this, SoundEvent.STOP);
                mPlayer.stop();
                mPlayer.release();
                mPlayer = null;
            }
        }
    }

    /**
     * Create a SoundManager.
     * @param context The android context to play sounds within.
     */
    public SoundManager(Context context) {
        mContext = context;
        mSharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
    }

    /**
     * Sound types of commands.
     */
    public enum CommandSound {
        START, // Used to play the start command sound
        STOP, // Used to play the stop command sound
    }

    /**
     * Sound types of executive planner goals.
     */
    public enum GoalSound {
        STARTED_GOAL, // Played when a new goal is started.
        COMPLETED_GOAL, // Played when a goal is completed.
        REJECTED_GOAL, // Played when a goal is rejected.
        ALARM, // Play the alarm sound effect.
        YOU_ARE_WELCOME, // Play the you're welcome sound effect.
    }

    /**
     * Plays a sound from an URI. Acceptable formats are anything the Android SDK will support.
     * The full list is available at
     * https://developer.android.com/guide/topics/media/media-formats.html.
     * @param uri The URI to play.
     * @param soundLevel The sound level.
     * @param looping The sound should loop.
     * @return The sound object.
     */
    public Sound playUriSound(Uri uri, SoundLevel soundLevel, boolean looping) {
        return wrapSoundFromMediaPlayer(MediaPlayer.create(mContext, uri),
                soundLevel, looping, "URI:" + uri);
    }

    /**
     * Wraps a MediaPlayer into a Sound and adds it to the set of currently playing Sound objects.
     * @param player The player, could be null.
     * @param soundLevel The SoundLevel of the sound to play.
     * @param looping If true, the sound will loop continuously.
     * @param description The sound description.
     * @return The Sound object or null.
     */
    private Sound wrapSoundFromMediaPlayer(MediaPlayer player, SoundLevel soundLevel,
            boolean looping, String description) {
        if (player == null) {
            Log.w(TAG, "Warning sound was null");
            return null;
        }
        if (!canPlaySoundLevel(soundLevel)) {
            Log.i(TAG, "Not playing sound for level: " + soundLevel);
            return null;
        }
        player.setLooping(looping);
        player.start();
        Sound r = new Sound(player, soundLevel, looping, description);
        synchronized (this) {
            if (mShutdown) {
                r.stop();
                return null;
            }
            mSounds.add(r);
            soundLog(r, SoundEvent.START);
        }
        return r;
    }

    /**
     * Determine if we can play a given SoundLevel.
     * @param soundLevel The SoundLevel.
     * @return True if we can play it.
     */
    private boolean canPlaySoundLevel(SoundLevel soundLevel) {
        return (soundLevel == SoundLevel.AUTOGEN && mAutogenSoundsEnabled)
                || (soundLevel == SoundLevel.USER && mUserSoundsEnabled)
                || (soundLevel == SoundLevel.COMMAND && mCommandSoundsEnabled)
                || (soundLevel == SoundLevel.ANIMATION)
                || (soundLevel == SoundLevel.SOUND_BOARD);
    }

    /**
     * Update the sounds queue.
     */
    public synchronized void update() {
        mUserSoundsEnabled = mSharedPreferences.getBoolean(
                mContext.getString(R.string.pref_user_sounds), true);
        mAutogenSoundsEnabled = mSharedPreferences.getBoolean(
                mContext.getString(R.string.pref_autogen_sounds), true);
        mCommandSoundsEnabled = mSharedPreferences.getBoolean(
                mContext.getString(R.string.pref_command_sounds), true);

        final Set<Sound> finishedSounds = new HashSet<>();
        for (Sound s : mSounds) {
            if (!canPlaySoundLevel(s.getSoundLevel())) {
                soundLog(s, SoundEvent.DISABLED);
                s.stop();
            }
            if (s.isPlaying() && s.soundHasTimedOut()) {
                Log.e(TAG, "Sound timed out: " + s.getDescription());
                s.stop();
                finishedSounds.add(s);
                soundLog(s, SoundEvent.TIMEOUT);
            } else if (!s.isPlaying()) {
                Log.i(TAG, "Sound has finished: " + s.getDescription());
                s.stop();
                finishedSounds.add(s);
                soundLog(s, SoundEvent.REMOVE);
            }
        }
        mSounds.removeAll(finishedSounds);
    }

    /**
     * Log when a sound completes or starts.
     * @param sound The sound to log.
     * @param event The sound event type.
     */
    private void soundLog(Sound sound, SoundEvent event) {
        Log.i(TAG, "Sound event: " + sound.getDescription() + " " + event);
        Bundle bundle = new Bundle();
        bundle.putString(EVENT_SOUND_DESCRIPTION, sound.getDescription());
        bundle.putString(EVENT_SOUND_LEVEL, sound.getSoundLevel().toString());
        bundle.putString(EVENT_SOUND_EVENT, event.toString());
        FirebaseAnalytics.getInstance(mContext).logEvent(EVENT_SOUND, bundle);
    }

    /**
     * Stops all existing sounds at a given sound level.
     * @param level Stop sounds at this level.
     */
    public synchronized void stopAllSounds(SoundLevel level) {
        for (Sound s : mSounds) {
            if (s.getSoundLevel() == level) {
                s.stop();
            }
        }
    }

    /**
     * Stops all existing sounds at all levels.
     */
    public synchronized void stopAllSounds() {
        for (Sound s : mSounds) {
            s.stop();
        }
    }

    /**
     * Shuts down the manager.
     */
    public synchronized void shutdown() {
        mShutdown = true;
        stopAllSounds();
        update();
    }
}
